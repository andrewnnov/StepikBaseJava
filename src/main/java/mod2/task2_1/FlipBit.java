package mod2.task2_1;

/*
Реализуйте метод flipBit, изменяющий значение одного бита заданного целого числа на противоположное. Данная задача актуальна, например, при работе с битовыми полями.

Договоримся, что биты нумеруются от младшего (индекс 1) к старшему (индекс 32).

Воспользуйтесь предоставленным шаблоном. Декларацию класса, метод main и обработку ввода-вывода добавит проверяющая система.

Sample Input:

0 1
Sample Output:

//1
// */
//
public class FlipBit {

    /**
     * Flips one bit of the given <code>value</code>.
     *
     * @param value     any number
     * @param bitIndex  index of the bit to flip, 1 <= bitIndex <= 32
     * @return new value with one bit flipped
     */
    public static int flipBit(int value, int bitIndex) {

        return value ^ (1 << (bitIndex - 1));
    }
}


/*
@Виктор_Максаков
Мне кажется, тяжело человеку который только начинает вникать в программирование "увидеть" как он будет двигать эти биты. А если еще и не понимает зачем... То совсем тяжко.

По поводу где это применяется.
На вскидку, могу привести два примера, из реальной жизни.
1. ОС Unix\Linux\FreeBSD\MacOSX. Права на файлы, задаются с помощью битовых масок.
2. Для экономии памяти, можно использовать битовые маски. (Например, хранить пол человека с помощью бита. Или, кодировать типы комплектующих ПК с помощью битов. Например, бит № 1: 0 = стационарный ПК, 1 = ноутбук; бит №2: 0 = AMD, 1 = intel... Ну и т.д.)

Как это работает.
В первую очередь, надо разобраться с представлением чисел в компьютере. Числа в ПК хранятся в двоичном виде (т.е. в виде нулей и единичек). Для примера, можно рассмотреть 8 бит. И так, представьте 8 спичечных коробков, которые лежат в ряд перед Вами на столе. У коробка (я говорю о свойстве одного, любого коробка) может быть только 2 состояния. Состояние 1: он пуст. в нем ничего нет. Состояние 2: в нем есть одна спичка. Т.е. В один момент времени, коробок может быть только в одном состоянии. Либо в нем есть спичка, либо нет.
Теперь. Порядок коробков - имеет значение. Справа, значение коробка самое маленькое. Слева - самое большое. (Как и в десятичной системе счисления, положение цифры в числе означает ее вес. Например 758. В данном случае 5 означает количество десятков в числе. Также и в двоичных числах. В зависимости от того в какой коробке по счету находиться спичка, такой величины число это и символизирует.)
Номинал коробков справа налево, это степени числа 2. Т.е. нулевая степень двойки = 1й коробок, первая степень = второй коробок, вторая с. = третий коробок, и т.д.

№ коробка:               8     7      6     5    4    3   2   1
"Коробок" :)             [ ]   [ ]    [ ]   [ ]   [ ]  [ ]  [ ] [ ]
Степень двойки:   128  64   32   16   8    4    2   1

Если положить спичку в коробок №1 (а в остальных пусто), это будет означать число равное 1. Если добавить спичку в коробок №2, как Вы думаете, какое число это будет означать? :) А если положить еще одну спичку в коробок №3, тогда какое число получиться? (Необходимо сложить степени двойки только тех коробков, в которых в данный момент лежат спички. Т.е. 1 + 2 + 4 = 7) А если убрать теперь спичку из коробка №2 ? Какое теперь число храниться в нашей "памяти"?

Т.е. Если мы пишем число 42 в десятичном виде, это означает, что в ПК оно храниться в виде двоичного числа, у которого биты 6, 4 и 2, равны единице. А все остальные биты - равны 0.

Теперь, когда представили число в двоичном виде, можно подумать о том, как прочесть определенный бит (коробок :) ) этого числа. Рекомендую посмотреть таблицы истинности для битовых операций. Что будет, если выполнить операцию логическое исключающее или ("XOR", "^") над числами: 0 и 0, 0 и 1, 1 и 1? Каков будет результат? А если выполнить побитовое или ("OR", "|")? Какой результат для тех же чисел, и какова разница с XOR?

Ну и финальный штрих... Как перемещать установленный бит, из первого "коробка", например в 4? (Побитовый сдвиг ;) ).

Надеюсь, это кому-то поможет понять КАК это работает :)
 */
